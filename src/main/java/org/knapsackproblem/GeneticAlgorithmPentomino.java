package org.knapsackproblem;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;

public class GeneticAlgorithmPentomino {
    public static int[] alphabet = new int[56];
    static int PopulationSize = 50; 
    final static int String_length = 83; // Length of string Calculated for A
    static int child_count = 6;
    static int currentChild_count;
    static double mutationrate = 5; //percentage of mutation 
    
    /**
     * Combines all the parts of our genetic Algorithm
     * 
     * @param Container
     * @param generations amount of generations
     * @param crossoverPoints if you put more then 2 potential of crashing if you are lucky enough
     * @return
     */
    public static potential_load_pentomino[] geneticAlgorithm(int[][][] Container, int generations, int crossoverPoints){
        potential_load_pentomino[] Population = generatepopulation(Container);
        optimizationSortFitness(Population);
        int count=0;
        for (int k = 0; k < generations; k++) {
            count++;
            int amountOfChildren = PopulationSize - child_count; 
            for (int i = 0; i < amountOfChildren/2; i++) {
                Random rand = new Random();
                crossover(Population[rand.nextInt(6)].getChromosome(), Population[rand.nextInt(6)].getChromosome(), Population, crossoverPoints);
            }
            for (int i = 0; i < Population.length; i++) {
                Population[i].changeFitnessValue(questionD(Population[i].getChromosome(), Container));
            }
            optimizationSortFitness(Population);
            currentChild_count = child_count;
            // System.out.println(mutationrate);
           System.out.println(Population[0].getFitnessValue());
            // System.out.println("mutationratemutationratemutationratemutationrate= "+mutationrate);
        }
        
        return Population;
    }
    /**
     * Gaussian distribution generator
     * @return random variable generated by a gaussian distributor and shifted to be greater than 2
     */
    public static double next_gaussian()
    {
    Random random = new Random();
    double x = random.nextGaussian();  // Generation the variable. It generates an initial [-1,1] gaussian distribution
    double y = (x * 0.5) + 2;          // Shift it to be greater than 1
    return Math.rint(y * 100000.0) * 0.00001; // Quantize to step size 0.00001
    }
    /**
     * TODO Sonya
     * @param parent1
     * @param parent2
     * @param Population
     */
    public static void crossover(int[] parent1, int[] parent2, potential_load_pentomino[] Population, int crossoverPoints){
        int[] crossoverPosition = new int[crossoverPoints+1];
        crossoverPosition[0] = 0;
        crossoverPosition = generateCrossoverPosition(parent1, crossoverPosition);
        crossoverPosition[0] = 0;
        int[] child1 = new int[parent1.length];
        int[] child2 = new int[parent1.length];
        // making child 1 and 2
        for (int j = 0; j < crossoverPoints; j++) {
            for(int i = crossoverPosition[j]; i < crossoverPosition[j + 1]; i++) {
                Random random2 = new Random();
                if((int)mutationrate > random2.nextInt(100)){
                    child1[i] = random2.nextInt(Cargo.resultPentominoes.size());
                    child2[i] = random2.nextInt(Cargo.resultPentominoes.size());
                }
                else{
                    if(i % 2 == 0 ){
                    child1[i] = parent1[i];
                    child2[i] = parent2[i];
                    }
                    else{
                    child1[i] = parent2[i];
                    child2[i] = parent1[i];
                    }
                }
            }
        }
        Population[child_count].changeChromosome(child1);
        currentChild_count++; 
        Population[child_count].changeChromosome(child2);
        currentChild_count++;
    }
    /**
     * Sonya
     * This method generates a random index which will be a crossover point
     * @param parent1
     * @return
     */
    public static int[] generateCrossoverPosition(int[] parent1, int[] crossoverPosition){
        int parts = parent1.length;
        Random random = new Random();
        for (int i = 1; i < crossoverPosition.length; i++) {
            crossoverPosition[i] = random.nextInt(crossoverPosition[i-1], parts);
        }
        return crossoverPosition;
    }
    /**
     * TODO Aurelien
     * @param Container
     * @return
     */
    public static potential_load_pentomino[] generatepopulation(int[][][] Container){
        //Building a char list : alphabet containing letters from A to G.
        // Building Object list : our population
        potential_load_pentomino[] Population = new potential_load_pentomino[PopulationSize];
        // Building Random number generator
        int random;
        Random generator = new Random();
        // creating population of individuals built randomly.
        for(int i = 0; i < PopulationSize; i++){
            int[] Chromosome = new int[String_length];
            for(int j = 0; j < String_length ; j++){ // length 7 : ABCDEFG
                random = generator.nextInt(Cargo.resultPentominoes.size()); // Random number generator between 0 and 7.
                Chromosome[j] = random;
            }
            Population[i] = new potential_load_pentomino(Chromosome, calculateFitness(Chromosome, Container));
        }
        // to print population
       /*
        for(int i = 0; i<Population.length; i++){
                System.out.println(Arrays.toString(Population[i].getChromosome()));
                System.out.println(Population[i].getFitnessValue());
        }
        */
        return Population;
    }
    /**
     * Eden
     * Sorts the Population using the fitness values
     * @param Population
     * @return
     */
    static potential_load_pentomino [] optimizationSortFitness(potential_load_pentomino[] Population){
        Arrays.sort(Population, (b, a) -> Double.compare(a.getFitnessValue(), b.getFitnessValue())); // Mapping functions.
        return Population;
    }
    /**
     * Calculates the fitness value by counting empty squares
     * @param chararray
     * @param addContainer
     * @return
     */
    static double calculateFitness(int[] intarray, int[][][] addContainer){
        int fitness = 0;
        for (int i = 0; i < addContainer.length; i++) {
            for (int j = 0; j < addContainer[0].length; j++) {
                for (int j2 = 0; j2 < addContainer[0][0].length; j2++) {
                    addContainer[i][j][j2] = 0;
                }
            }
        }
        addContainer = Main.recursiveAdding_pentomino(0, 0, 0, 0, 0, addContainer, intarray);
        for (int i = 0; i < addContainer.length; i++) {
            for (int j = 0; j < addContainer[0].length; j++) {
                for (int j2 = 0; j2 < addContainer[0][0].length; j2++) {
                    if(addContainer[i][j][j2] != 0){
                        fitness += 1;
                    }
                }
            }
        }
        return (fitness/Main.volumeTotal)*100.0;
    }
    /**
     * Calculates fitness with values of pentominoes
     * @param intArray
     * @param addContainer
     * @return
     */
    static double questionD(int[] intArray, int[][][] addContainer){
        double fitness = 0;
        Main.lastpiecePentomino = 0;
        for (int i = 0; i < addContainer.length; i++) {
            for (int j = 0; j < addContainer[0].length; j++) {
                for (int j2 = 0; j2 < addContainer[0][0].length; j2++) {
                    addContainer[i][j][j2] = 0;
                }
            }
        }
        Main.lastpiecePentomino = Main.recursiveAddingValues_pentomino(0, 0, 0, 0, 0, addContainer, intArray);
        for (int i = 0; i < Main.lastpiecePentomino; i++) {
            fitness += calculateValue_pentomino(intArray[i]);
        }
        return (fitness/1320)*100.0;
    }
    static int calculateValue_pentomino(int i){
        if(i >= 0 && i <= 7)
            return 5;
        else if(i >= 8 && i <= 31)
            return 3;
        return 4;

    }
}
